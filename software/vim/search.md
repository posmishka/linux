search
======

#### Поиск
/pattern поиск
?pattern поиск в обратном направлении
n Повторить поиск в том же направлении.
N Повторить поиск в противоположном направлении.
/ENTER Повторить поиск вперед.
?ENTER Повторить поиск назад.
d/pattern удаление от текущей позиции до pattern. посимвольно, строки не удаляются.
'' возвращает курсор на место начала поиска
`` возвращает курсор в начало строки с места начала поиска

/Выражение               поиск выражения в файле
\cВыражение              поиск без учета регистра
n                        следующее совпадение
N                        предыдущее совпадение
:%s/foo/bar/gi           замена строк, см http://eax.me/regular-expr/


поиск в строке:
fx переместит курсор на следующее вхождение символа x
Fx переместит курсор на предидущее вхождение символа х
tx переместит курсор на символ, предшествующий следующему вхождению x
; Для повторного поиска в том же направлении
, Для повторного поиска в противоположном направлении
dfx удаляет все до указанного символа x включительно
ct. изменение текста до конца предложения, оставляя завершающую точку.

== Поиск по всему проекту ==
:vimgrep /EXPR/ **/*.c   поиск по регулярному выражению
:copen                   показать все найденные места
:close                   скрыть все найденные места
:cn                      переход к следующему результату
:cp                      переход к предыдущему результату

/word	Искать слово “word” сверху вниз
?word	Искать слово “word” снизу вверх
/jo[ha]n>	Искать “john” или “joan”
/\< the	Искать слова, начинающееся на “the”
/the\>	Искать слова, заканчивающиеся на “the”
/\< the\>	Искать “the” (точное соответствие)
/\< …. \>	Искать слова из четырех символов
/fred\|joe	Искать “fred” или “joe”
/\<\d\d\d\d\>	Искать 4 цифры подряд
/^\n\{3}	Искать 3 пустые строки
:bufdo /searchstr/	Искать во всех открытых файлах

#### Замена

:%s/old/new/g	Заменить все вхождения “old” на “new”
:%s/old/new/gw	Заменить все вхождения “old” на “new” с запросом подтверждения
:2,35s/old/new/g	Заменить все вхождения “old” на “new” между 2 и 35 строками
:5,$s/old/new/g	Заменить все вхождения “old” на “new” начиная с 5 строки и до конца файла
:%s/^/hello/g	Добавить “hello” в начало каждой строки
:%s/$/Harry/g	Добавить “Harry” в конец каждой строки
:%s/onward/forward/gi	Заменить “onward” на “forward” с учетом регистра
:%s/ *$//g	Убрать все пробелы
:g/string/d	Удалить все строки, содержащие “string”
:v/string/d	Удалить все строки, не содержащие “string”
:s/Bill/Steve/	Заменить первое вхождение “Bill” на “Steve” в текущей строке
:s/Bill/Steve/g	Заменить все вхождения “Bill” на “Steve” в текущей строке

Комментарий к замене: ...мне нужно во всем файле совершить замену

Abs[ 'выражение' ] -> | 'выражение' |

Если при описании разыскиваемой последовательности заключить какое-нибудь выражение в скобки \( \), то Vim поместит его в память под соответствующим номером (первое выражение под номером один, второе — два) и позволит в дальнейшем вызывать командой \x, где x — номер, под которым выражение было помещено в память.

Таким образом, нужная команда будет выглядеть примерно так:

:%s/Abs\[\([^\]]*\)\]/|\1|/g

Здесь стоит отметить, что для буквального совпадения квадратные скобки предваряются слешами, поскольку являются спецсимволами. Вообще любой спецсимвол, если должен участвовать в поиске, обозначая свое непосредственное значение, предваряется слешем: \^; \* и т.д. Сам слеш предваряется также слешем. Выглядит это так: для поиска последовательности '\cos' надо ввести '\\cos'.

...совершить замену вида

'Заглавная латинская буква''цифра' -> 'Заглавная латинская буква'_'цифра'

Самое тривиальное решение, которое напрашивается — перебрать все комбинации, если их немного. То есть, запустить замену сначала 'U1' -> 'U_1', потом 'U2' -> 'U_2' и т.п. Понятно, что это не наш метод. Мы вспомним, что есть квадратные скобки. И для того, чтобы найти одну заглавную латинскую букву, достаточно ввести шаблон '[A-Z]'. Но и это не предел. Для такого шаблона у Vim есть специальная аббревиатура: '\u' (от 'uppercase'). Для цифр же есть '\d' (от 'digit'). Подробнее о таких конструкциях можно почитать по адресу :help pattern.txt. С использованием этих аббревиатур команда для поиска примет вид

:%s/\(\u\)\(\d\)/\1_\2/g

Тут опять встречается группировка круглыми скобками: она позволяет при поиске поместить найденную букву и цифру в память под соотвествующими номерами, и впоследствии их оттуда извлечь, вызывая командами с теми же номерами: '\1' вызовет букву, а '\2' — цифру.
Регистр