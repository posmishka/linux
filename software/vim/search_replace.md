search_replace
======

#### Поиск
/pattern поиск
?pattern поиск в обратном направлении
n Повторить поиск в том же направлении.
N Повторить поиск в противоположном направлении.
/ENTER Повторить поиск вперед.
?ENTER Повторить поиск назад.
d/pattern удаление от текущей позиции до pattern. посимвольно, строки не удаляются.
'' возвращает курсор на место начала поиска
`` возвращает курсор в начало строки с места начала поиска

/Выражение               поиск выражения в файле
\cВыражение              поиск без учета регистра
n                        следующее совпадение
N                        предыдущее совпадение
:%s/foo/bar/gi           замена строк, см http://eax.me/regular-expr/



###### поиск
`:/pattern/d` удалить следующую найденную строку, содержащую шаблон pattern
`:/pattern/+d` удалить строку ниже той, что содержит шаблон
`:/p1/,/p2/d` удалить строки от первой, содержащей p1, до первой, содержащей p2
`:.,/pattern/m8` текст от текущей строки до первой, содержащей pattern перенести после строки 8
- `g` глобальный поиск шаблона
- `!g` поиск строк, не содержащих шаблон

`:g/pattern` переходит на последнее вхождение pattern в файле
`:g/pattern/p` выводит все строки, содержащие pattern
`:g!/pattern/nu` вывести строки и их номера, не содержащие pattern
`:3,20g/pattern/p` вывести строки с 3 по 20, содержащие pattern
`:1,5 m 10 | g/pattern/nu` перемещение, затем поиск с выводом строк



поиск в строке:
fx переместит курсор на следующее вхождение символа x
Fx переместит курсор на предидущее вхождение символа х
tx переместит курсор на символ, предшествующий следующему вхождению x
; Для повторного поиска в том же направлении
, Для повторного поиска в противоположном направлении
dfx удаляет все до указанного символа x включительно
ct. изменение текста до конца предложения, оставляя завершающую точку.

== Поиск по всему проекту ==
:vimgrep /EXPR/ **/*.c   поиск по регулярному выражению
:copen                   показать все найденные места
:close                   скрыть все найденные места
:cn                      переход к следующему результату
:cp                      переход к предыдущему результату

/word	Искать слово “word” сверху вниз
?word	Искать слово “word” снизу вверх
/jo[ha]n>	Искать “john” или “joan”
/\< the	Искать слова, начинающееся на “the”
/the\>	Искать слова, заканчивающиеся на “the”
/\< the\>	Искать “the” (точное соответствие)
/\< …. \>	Искать слова из четырех символов
/fred\|joe	Искать “fred” или “joe”
/\<\d\d\d\d\>	Искать 4 цифры подряд
/^\n\{3}	Искать 3 пустые строки
:bufdo /searchstr/	Искать во всех открытых файлах


#### Замена и регулярки
`:s/old/new/g` замена в текущей строке old на new
`:5,10s/old/new/g` поиск и замена в строках с 5 по 10
`:1,$s/old/new/g` то же что `:%s/old/new/g` замена по всему файлу
`:g/pattern/s/old/new/g` *обработать все строки :g - найти паттерн, в найденых строках заменить старые символы на новые в каждой найденной строке /g*
`:%s/старе/нове/gc` для подтверждения каждого изменения вхождения - с в конце


###### Регулярные выражения
`.` одиночный символ
`*` любое повторение символа перед звездочкой
`^` признак что регулярное выражение в начале строки
`$` признак что регулярное выражение в конце строки
`\` экранирование спец.символа
`\[\]` диапазон или список символов по которым искать \[:;A-Za-z( )\]
- *в скобках нужно экранировать `\ , -` и `]`*
- `^` в начале скобки - признак отрицания [^0-9] - не цифры

`\( \)` сохраняет содержимое во внутренний буфер, который можно использовать в замене значения. до девяти буферов. 
- *:%s/\(That\) or \(this\)/\2 or \1/ поменяет this и That местами*
- :s/\(abc\)\1/newline/ *найдет abcabc и поменяет на newline*

`\\< \\>` соответствие символам в начале и в конце слова
`~` регулярное выражение, которое использовалось в последнем поиске. *не применяется в подстановках, только в поиске /*

`&` в строке замены подставляет текст из строки поиска %s/hello/&, world/
`\u или \l` в строке замены делает следующим символ верхним или нижним регистром
`\U или \L` делает последующие символы в нижнем/верхнем регистре пока не встретит `\e или \E` или до конца того что подставляет

`:s` подставление предидущей замены
`:%&g` повторить прдидущую замену по всему тексту

#### Замена

:%s/old/new/g	Заменить все вхождения “old” на “new”
:%s/old/new/gw	Заменить все вхождения “old” на “new” с запросом подтверждения
:2,35s/old/new/g	Заменить все вхождения “old” на “new” между 2 и 35 строками
:5,$s/old/new/g	Заменить все вхождения “old” на “new” начиная с 5 строки и до конца файла
:%s/^/hello/g	Добавить “hello” в начало каждой строки
:%s/$/Harry/g	Добавить “Harry” в конец каждой строки
:%s/onward/forward/gi	Заменить “onward” на “forward” с учетом регистра
:%s/ *$//g	Убрать все пробелы
:g/string/d	Удалить все строки, содержащие “string”
:v/string/d	Удалить все строки, не содержащие “string”
:s/Bill/Steve/	Заменить первое вхождение “Bill” на “Steve” в текущей строке
:s/Bill/Steve/g	Заменить все вхождения “Bill” на “Steve” в текущей строке

Комментарий к замене: ...мне нужно во всем файле совершить замену

Abs[ 'выражение' ] -> | 'выражение' |

Если при описании разыскиваемой последовательности заключить какое-нибудь выражение в скобки \( \), то Vim поместит его в память под соответствующим номером (первое выражение под номером один, второе — два) и позволит в дальнейшем вызывать командой \x, где x — номер, под которым выражение было помещено в память.

Таким образом, нужная команда будет выглядеть примерно так:

:%s/Abs\[\([^\]]*\)\]/|\1|/g

Здесь стоит отметить, что для буквального совпадения квадратные скобки предваряются слешами, поскольку являются спецсимволами. Вообще любой спецсимвол, если должен участвовать в поиске, обозначая свое непосредственное значение, предваряется слешем: \^; \* и т.д. Сам слеш предваряется также слешем. Выглядит это так: для поиска последовательности '\cos' надо ввести '\\cos'.

...совершить замену вида

'Заглавная латинская буква''цифра' -> 'Заглавная латинская буква'_'цифра'

Самое тривиальное решение, которое напрашивается — перебрать все комбинации, если их немного. То есть, запустить замену сначала 'U1' -> 'U_1', потом 'U2' -> 'U_2' и т.п. Понятно, что это не наш метод. Мы вспомним, что есть квадратные скобки. И для того, чтобы найти одну заглавную латинскую букву, достаточно ввести шаблон '[A-Z]'. Но и это не предел. Для такого шаблона у Vim есть специальная аббревиатура: '\u' (от 'uppercase'). Для цифр же есть '\d' (от 'digit'). Подробнее о таких конструкциях можно почитать по адресу :help pattern.txt. С использованием этих аббревиатур команда для поиска примет вид

:%s/\(\u\)\(\d\)/\1_\2/g

Тут опять встречается группировка круглыми скобками: она позволяет при поиске поместить найденную букву и цифру в память под соотвествующими номерами, и впоследствии их оттуда извлечь, вызывая командами с теми же номерами: '\1' вызовет букву, а '\2' — цифру.
Регистр