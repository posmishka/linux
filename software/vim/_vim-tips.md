_vim-tips
========

### Remove ^M from the end of line

:e ++ff=do:e ++ff=dos 

The :e ++ff=dos command tells Vim to read the file again, forcing  dos file format. Vim will remove CRLF and LF-only line endings, leaving  only the text of each line in the buffer.

then 

:set ff=unix 
and finally 
:wq 

:s/^M$//

(Press Ctrl+V Ctrl+M to insert that ^M.)



**Как пользоваться vim**  
http://najomi.org/vim


**DATABASE QUERY**  
https://habamax.github.io/2019/09/02/use-vim-dadbod-to-query-databases.html


**vim-git**
https://itnan.ru/post.php?c=1&p=261783



:%s/old/new/g	Заменить все вхождения “old” на “new”
:%s/old/new/gw	Заменить все вхождения “old” на “new” с запросом подтверждения
:2,35s/old/new/g	Заменить все вхождения “old” на “new” между 2 и 35 строками
:5,$s/old/new/g	Заменить все вхождения “old” на “new” начиная с 5 строки и до конца файла
:%s/^/hello/g	Добавить “hello” в начало каждой строки
:%s/$/Harry/g	Добавить “Harry” в конец каждой строки
:%s/onward/forward/gi	Заменить “onward” на “forward” с учетом регистра
:%s/ *$//g	Убрать все пробелы
:g/string/d	Удалить все строки, содержащие “string”
:v/string/d	Удалить все строки, не содержащие “string”
:s/Bill/Steve/	Заменить первое вхождение “Bill” на “Steve” в текущей строке
:s/Bill/Steve/g	Заменить все вхождения “Bill” на “Steve” в текущей строке
:%s/\r//g	Убрать символ возврата каретки (Такие тексты обычно приходят от windows-пользователей)
:%s#>[^<]\+>##g	Очистить текст от HTML-тегов
:%s/^\(.*\)\n\1$/\1/	Удалить строки, повторяющиеся дважды
Ctrl+a	Увеличить число под курсором на единицу
Ctrl+x	Уменьшить число под курсором на единицу
ggVGg?	Преобразовать текст в Rot13
Комментарий к замене: ...мне нужно во всем файле совершить замену

Abs[ 'выражение' ] -> | 'выражение' |

Если при описании разыскиваемой последовательности заключить какое-нибудь выражение в скобки \( \), то Vim поместит его в память под соответствующим номером (первое выражение под номером один, второе — два) и позволит в дальнейшем вызывать командой \x, где x — номер, под которым выражение было помещено в память.

Таким образом, нужная команда будет выглядеть примерно так:

:%s/Abs\[\([^\]]*\)\]/|\1|/g

Здесь стоит отметить, что для буквального совпадения квадратные скобки предваряются слешами, поскольку являются спецсимволами. Вообще любой спецсимвол, если должен участвовать в поиске, обозначая свое непосредственное значение, предваряется слешем: \^; \* и т.д. Сам слеш предваряется также слешем. Выглядит это так: для поиска последовательности '\cos' надо ввести '\\cos'.

...совершить замену вида

'Заглавная латинская буква''цифра' -> 'Заглавная латинская буква'_'цифра'

Самое тривиальное решение, которое напрашивается — перебрать все комбинации, если их немного. То есть, запустить замену сначала 'U1' -> 'U_1', потом 'U2' -> 'U_2' и т.п. Понятно, что это не наш метод. Мы вспомним, что есть квадратные скобки. И для того, чтобы найти одну заглавную латинскую букву, достаточно ввести шаблон '[A-Z]'. Но и это не предел. Для такого шаблона у Vim есть специальная аббревиатура: '\u' (от 'uppercase'). Для цифр же есть '\d' (от 'digit'). Подробнее о таких конструкциях можно почитать по адресу :help pattern.txt. С использованием этих аббревиатур команда для поиска примет вид

:%s/\(\u\)\(\d\)/\1_\2/g

Тут опять встречается группировка круглыми скобками: она позволяет при поиске поместить найденную букву и цифру в память под соотвествующими номерами, и впоследствии их оттуда извлечь, вызывая командами с теми же номерами: '\1' вызовет букву, а '\2' — цифру.
Регистр